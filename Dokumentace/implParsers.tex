\chapter{Implementované Parsery}
\section{FormattedFileParser}
Jediný implementovaný parser v tomto programu je \texttt{FormattedFileParser}. Což nutně neznamená, že by nebyl zajímavý. Tento parser načítá strukturovaná data ze souboru. 

\textbf{Důležité upozornění}: parser očekává základní SI jednotky - metry, sekundy, kilogramy. Ale výstupní \texttt{simData\_t} obsahuje objekty se vzdáleností v AU($ 1,5.10^9 $ m), časem v rocích(pozemské - 365 dní) a hmotností v násobcích hmotnosti Slunce($ 1,988435.10^{30} $ kg přesně). Důvod je ten, že hodnoty v těchto jednotkách jsou více normalizované a dochází k menším zaokrouhlovacím chybám.

Nejdříve se podíváme na strukturu těchto dat a poté probereme jak je implementováno samotné načítání.
\subsection{Struktura dat}
Začneme hned příkladem, takto by například mohl vypadat takový vstupní soubor s daty:
\begin{lstlisting}
{ name<Sun>
color<1.0 0.88 0.0 1.0>
position<0.0 0.0>
velocity<0.0 0.0>
mass<1.98843e30> }

{ name<Earth>
color<0.17 0.63 0.83 1.0>
position< 149.6e9 0.0>
velocity<0 29800.0>
mass<5.9736e24> }

{ name<Moon>
color<0.2 0.2 0.2 1.0>
position< 150.0e9 0.0>
velocity<0 30822.0>
mass<7.3476e22> }
\end{lstlisting}
\texttt{FormattedFileParser} by z tohoto souboru vytvořil data obsahující 3 objekty pojmenované - Sun, Earth, Moon s určitými vlastnostmi.

Každý objekt je popsán uvnitř páru složených závorek \textbf{\texttt{\{\}}}.
Všechny parametry objektu jsou dobrovolné, čili \lstinline|{}| je validní bezejmenný objekt, který se nachází v klidu na pozici \texttt{(0,0)} a má nulovou hmotnost. Pokud se ale parametr objeví, musí mít správný formát, který je obecně \texttt{název<hodnoty>}. Následuje přesný výčet a formát parametrů:
\paragraph{name$ < $jméno$ > $ } - jméno objektu. Jsou dovoleny pouze znaky ANSCII, čili bez diakritiky. Pokud není uvedeno, pak je prázdné.
\paragraph{color$ < $R G B A$ > $} - barva objektu. Očekávají se 4 desetinná čísla v rozmezi od 0.0 do 1.0 představující barvu ve formátu RGBA. Pokud není uvedeno, pak je bíla.
\paragraph{velocity$ < $X Y$ > $} - počáteční rychlost objektu. Očekává dvě desetinná čísla reprezentující rychlost ve vodorovném a svislém směru. Nesmí zde být napsány fyzikální jednotky - tzn. \texttt{velocity$ < $10e2 m/s 8e3 m/s$ > $} \textbf{není} validní vstup. Ale implicitně by hodnoty měly být v m/s . Pokud není uvedeno, pak je (0,0).
\paragraph{position$ < $X Y$ > $} - počáteční pozice objektu. Identické s rychlostí, očekávají se hodnoty v metrech.
\paragraph{mass $ < $hmotnost$ > $ } - hmotnost objektu vyjádřená jedním desetinným číslem v kilogramech. Také zde nesmí být jednotky uvedeny. Pokud není uvedeno, pak je nulová hmotnost.
\paragraph{Dodatek k číslům} - jsou povoleny jak celá, tak desetinná čísla. Je dovolena jak desetinná tečka, tak čárka. Číslo 104.25 se můžeme zapsat například následujícími způsoby: $ 104.25 \quad 1.0425e2 \quad 1042,5e\text{-}1 $.
Parser \textbf{neumí} aritmetiku, takže následující \textbf{není} validní vstup: $ 10425/100 \quad 104 + 0.25 \quad 1.0425 * 10^2 $.
\paragraph{}
\texttt{FormattedFileParser} je relativně shovívavý k formátování, takže následující je opravdu ekvivalentní k definici objektu \texttt{Sun} z předchozího příkladu, ovšem čitelnost takového vstupu ponecháme bez komentáře. 
\begin{lstlisting}
				{ name		Bylo nebylo	<Sun> za 
sedmerocolor	horami <1.0 	   0.88 			0.0 	1.0 a
 		sedmero
	velocityrekamiposition		jedno								<
0.0 
 0.0  male 		mass	
 <					1.98843e30  kralovstvi
> }

\end{lstlisting}

\subsection{Detaily implementace}
Takto vypadá declarace konstruktoru: \lstinline|FormattedFileParser(const std::string& inputFileName,const std::string& outputFileName="");|
Parser tedy očekává vstupní a případně výstupní jméno souboru,\textbf{ včetně} cesty a přípony k souboru. Samotné načítání a ukládání probíhá v metodách \texttt{Load()} respektive \texttt{Save()}.

Na vlastní implementaci není koncepčně nic extra zajímavého, přesná implementace je samozřejmě ve zdrojových kódech programu. \texttt{Load()} načte celý soubor do \texttt{std::string} ve kterém si pak vždy najde dvojici \{\} ve které se pokusí najít názvy parametrů. Pokud nějaký najde, pak k němu ještě najde nejbližší dvojici $ <> $  ve které poté očekává správné hodnoty. Tento jednoduchý způsob zajišťuje výše ukázanou flexibilitu formátování. Všechno ostatní, co by se v dokumentu mohlo nacházet prostě ignoruje. \texttt{Save()} vytvoří soubor, pokud byl nějaký zadán, do kterého předaná data uloží. Což se děje podobným způsobem, kde každý parametr "zabalí" do správného formátu.

Při nekorektním vstupu, nemožnosti otevřít vstupní soubor nebo vytvořit soubor výstupní vyvolají funkce vyjímku \texttt{Exception}.

Je pravda, že načítání by nutně nemuselo načítat celý soubor najednou, ale pouze  bloky závorek. Ale při velikosti textových souborů a operační paměti průměrného počítače nebyla paměť nejvyšší prioritou při programování zpracování vstupu.
